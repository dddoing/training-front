exports.id = "vendors-training-shared_node_modules_feather-route-matcher_feather-route-matcher_js";
exports.ids = ["vendors-training-shared_node_modules_feather-route-matcher_feather-route-matcher_js"];
exports.modules = {

/***/ "../training-shared/node_modules/feather-route-matcher/feather-route-matcher.js":
/*!**************************************************************************************!*\
  !*** ../training-shared/node_modules/feather-route-matcher/feather-route-matcher.js ***!
  \**************************************************************************************/
/***/ (function(module) {

(function (global, factory) {
   true ? module.exports = factory() :
  0;
}(this, (function () { 'use strict';

  // regexes borrowed from backbone
  var optionalParam = /\((.*?)\)/g;
  var namedParam = /(\(\?)?:\w+/g;
  // eslint-disable-next-line no-useless-escape
  var escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g;
  var splatParam = /\*/g;

  // Parses a URL pattern such as `/users/:id`
  // and builds and returns a regex that can be used to
  // match said pattern. Credit for these
  // regexes belongs to Jeremy Ashkenas and the
  // other maintainers of Backbone.js
  //
  // It has been modified for extraction of
  // named parameters from the URL
  var parsePattern = function (pattern) {
    var names = [];
    pattern = pattern
      .replace(escapeRegExp, '\\$&')
      .replace(optionalParam, '(?:$1)?')
      .replace(namedParam, function (match, optional) {
        names.push(match.slice(1));
        return optional ? match : '([^/?]+)'
      })
      .replace(splatParam, function () {
        names.push('path');
        return '([^?]*?)'
      });

    return {
      regExp: new RegExp('^' + pattern + '(?:\\?([\\s\\S]*))?$'),
      namedParams: names
    }
  };

  function index (routes) {
    var keys = Object.keys(routes);
    var routeCache = {};

    // loop through each route we're
    // and build the shell of our
    // route cache.
    for (var item in routes) {
      routeCache[item] = {
        value: routes[item]
      };
    }

    // main result is a function that can be called
    // with the url
    return function (url) {
      var params;
      var route;

      // start looking for matches
      var matchFound = keys.some(function (key) {
        var parsed;

        // fetch the route pattern from the cache
        // there will always be one
        route = routeCache[key];

        // if the route doesn't already have
        // a regex we never generated one
        // so we do that here lazily.
        // Parse the pattern to generate the
        // regex once, and store the result
        // for next time.
        if (!route.regExp) {
          parsed = parsePattern(key);
          route.regExp = parsed.regExp;
          route.namedParams = parsed.namedParams;
          route.pattern = key;
        }

        // run our cached regex
        var result = route.regExp.exec(url);

        // if null there was no match
        // returning falsy here continues
        // the `Array.prototype.some` loop
        if (!result) {
          return
        }

        // remove other cruft from result
        result = result.slice(1, -1);

        // reduce our match to an object of named parameters
        // we've extracted from the url
        params = result.reduce(function (obj, val, index) {
          if (val) {
            obj[route.namedParams[index]] = val;
          }
          return obj
        }, {});

        // stops the loop
        return true
      });

      // no routes matched
      if (!matchFound) {
        return null
      }

      return {
        value: route.value,
        params: params,
        url: url,
        pattern: route.pattern
      }
    }
  }

  return index;

})));
//# sourceMappingURL=feather-route-matcher.js.map


/***/ })

};
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFpbmluZy1mcm9udC8uLi90cmFpbmluZy1zaGFyZWQvbm9kZV9tb2R1bGVzL2ZlYXRoZXItcm91dGUtbWF0Y2hlci9mZWF0aGVyLXJvdXRlLW1hdGNoZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0EsRUFBRSxLQUE0RDtBQUM5RCxFQUFFLENBQzJEO0FBQzdELENBQUMscUJBQXFCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJOztBQUViO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQztBQUNEIiwiZmlsZSI6InZlbmRvcnMtdHJhaW5pbmctc2hhcmVkX25vZGVfbW9kdWxlc19mZWF0aGVyLXJvdXRlLW1hdGNoZXJfZmVhdGhlci1yb3V0ZS1tYXRjaGVyX2pzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XHJcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcclxuICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5jcmVhdGVNYXRjaGVyID0gZmFjdG9yeSgpKTtcclxufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG4gIC8vIHJlZ2V4ZXMgYm9ycm93ZWQgZnJvbSBiYWNrYm9uZVxyXG4gIHZhciBvcHRpb25hbFBhcmFtID0gL1xcKCguKj8pXFwpL2c7XHJcbiAgdmFyIG5hbWVkUGFyYW0gPSAvKFxcKFxcPyk/OlxcdysvZztcclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcclxuICB2YXIgZXNjYXBlUmVnRXhwID0gL1tcXC17fVxcW1xcXSs/LixcXFxcXFxeJHwjXFxzXS9nO1xyXG4gIHZhciBzcGxhdFBhcmFtID0gL1xcKi9nO1xyXG5cclxuICAvLyBQYXJzZXMgYSBVUkwgcGF0dGVybiBzdWNoIGFzIGAvdXNlcnMvOmlkYFxyXG4gIC8vIGFuZCBidWlsZHMgYW5kIHJldHVybnMgYSByZWdleCB0aGF0IGNhbiBiZSB1c2VkIHRvXHJcbiAgLy8gbWF0Y2ggc2FpZCBwYXR0ZXJuLiBDcmVkaXQgZm9yIHRoZXNlXHJcbiAgLy8gcmVnZXhlcyBiZWxvbmdzIHRvIEplcmVteSBBc2hrZW5hcyBhbmQgdGhlXHJcbiAgLy8gb3RoZXIgbWFpbnRhaW5lcnMgb2YgQmFja2JvbmUuanNcclxuICAvL1xyXG4gIC8vIEl0IGhhcyBiZWVuIG1vZGlmaWVkIGZvciBleHRyYWN0aW9uIG9mXHJcbiAgLy8gbmFtZWQgcGFyYW1ldGVycyBmcm9tIHRoZSBVUkxcclxuICB2YXIgcGFyc2VQYXR0ZXJuID0gZnVuY3Rpb24gKHBhdHRlcm4pIHtcclxuICAgIHZhciBuYW1lcyA9IFtdO1xyXG4gICAgcGF0dGVybiA9IHBhdHRlcm5cclxuICAgICAgLnJlcGxhY2UoZXNjYXBlUmVnRXhwLCAnXFxcXCQmJylcclxuICAgICAgLnJlcGxhY2Uob3B0aW9uYWxQYXJhbSwgJyg/OiQxKT8nKVxyXG4gICAgICAucmVwbGFjZShuYW1lZFBhcmFtLCBmdW5jdGlvbiAobWF0Y2gsIG9wdGlvbmFsKSB7XHJcbiAgICAgICAgbmFtZXMucHVzaChtYXRjaC5zbGljZSgxKSk7XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbmFsID8gbWF0Y2ggOiAnKFteLz9dKyknXHJcbiAgICAgIH0pXHJcbiAgICAgIC5yZXBsYWNlKHNwbGF0UGFyYW0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBuYW1lcy5wdXNoKCdwYXRoJyk7XHJcbiAgICAgICAgcmV0dXJuICcoW14/XSo/KSdcclxuICAgICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcmVnRXhwOiBuZXcgUmVnRXhwKCdeJyArIHBhdHRlcm4gKyAnKD86XFxcXD8oW1xcXFxzXFxcXFNdKikpPyQnKSxcclxuICAgICAgbmFtZWRQYXJhbXM6IG5hbWVzXHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gaW5kZXggKHJvdXRlcykge1xyXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyb3V0ZXMpO1xyXG4gICAgdmFyIHJvdXRlQ2FjaGUgPSB7fTtcclxuXHJcbiAgICAvLyBsb29wIHRocm91Z2ggZWFjaCByb3V0ZSB3ZSdyZVxyXG4gICAgLy8gYW5kIGJ1aWxkIHRoZSBzaGVsbCBvZiBvdXJcclxuICAgIC8vIHJvdXRlIGNhY2hlLlxyXG4gICAgZm9yICh2YXIgaXRlbSBpbiByb3V0ZXMpIHtcclxuICAgICAgcm91dGVDYWNoZVtpdGVtXSA9IHtcclxuICAgICAgICB2YWx1ZTogcm91dGVzW2l0ZW1dXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbWFpbiByZXN1bHQgaXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBjYWxsZWRcclxuICAgIC8vIHdpdGggdGhlIHVybFxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh1cmwpIHtcclxuICAgICAgdmFyIHBhcmFtcztcclxuICAgICAgdmFyIHJvdXRlO1xyXG5cclxuICAgICAgLy8gc3RhcnQgbG9va2luZyBmb3IgbWF0Y2hlc1xyXG4gICAgICB2YXIgbWF0Y2hGb3VuZCA9IGtleXMuc29tZShmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgdmFyIHBhcnNlZDtcclxuXHJcbiAgICAgICAgLy8gZmV0Y2ggdGhlIHJvdXRlIHBhdHRlcm4gZnJvbSB0aGUgY2FjaGVcclxuICAgICAgICAvLyB0aGVyZSB3aWxsIGFsd2F5cyBiZSBvbmVcclxuICAgICAgICByb3V0ZSA9IHJvdXRlQ2FjaGVba2V5XTtcclxuXHJcbiAgICAgICAgLy8gaWYgdGhlIHJvdXRlIGRvZXNuJ3QgYWxyZWFkeSBoYXZlXHJcbiAgICAgICAgLy8gYSByZWdleCB3ZSBuZXZlciBnZW5lcmF0ZWQgb25lXHJcbiAgICAgICAgLy8gc28gd2UgZG8gdGhhdCBoZXJlIGxhemlseS5cclxuICAgICAgICAvLyBQYXJzZSB0aGUgcGF0dGVybiB0byBnZW5lcmF0ZSB0aGVcclxuICAgICAgICAvLyByZWdleCBvbmNlLCBhbmQgc3RvcmUgdGhlIHJlc3VsdFxyXG4gICAgICAgIC8vIGZvciBuZXh0IHRpbWUuXHJcbiAgICAgICAgaWYgKCFyb3V0ZS5yZWdFeHApIHtcclxuICAgICAgICAgIHBhcnNlZCA9IHBhcnNlUGF0dGVybihrZXkpO1xyXG4gICAgICAgICAgcm91dGUucmVnRXhwID0gcGFyc2VkLnJlZ0V4cDtcclxuICAgICAgICAgIHJvdXRlLm5hbWVkUGFyYW1zID0gcGFyc2VkLm5hbWVkUGFyYW1zO1xyXG4gICAgICAgICAgcm91dGUucGF0dGVybiA9IGtleTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJ1biBvdXIgY2FjaGVkIHJlZ2V4XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJvdXRlLnJlZ0V4cC5leGVjKHVybCk7XHJcblxyXG4gICAgICAgIC8vIGlmIG51bGwgdGhlcmUgd2FzIG5vIG1hdGNoXHJcbiAgICAgICAgLy8gcmV0dXJuaW5nIGZhbHN5IGhlcmUgY29udGludWVzXHJcbiAgICAgICAgLy8gdGhlIGBBcnJheS5wcm90b3R5cGUuc29tZWAgbG9vcFxyXG4gICAgICAgIGlmICghcmVzdWx0KSB7XHJcbiAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJlbW92ZSBvdGhlciBjcnVmdCBmcm9tIHJlc3VsdFxyXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgxLCAtMSk7XHJcblxyXG4gICAgICAgIC8vIHJlZHVjZSBvdXIgbWF0Y2ggdG8gYW4gb2JqZWN0IG9mIG5hbWVkIHBhcmFtZXRlcnNcclxuICAgICAgICAvLyB3ZSd2ZSBleHRyYWN0ZWQgZnJvbSB0aGUgdXJsXHJcbiAgICAgICAgcGFyYW1zID0gcmVzdWx0LnJlZHVjZShmdW5jdGlvbiAob2JqLCB2YWwsIGluZGV4KSB7XHJcbiAgICAgICAgICBpZiAodmFsKSB7XHJcbiAgICAgICAgICAgIG9ialtyb3V0ZS5uYW1lZFBhcmFtc1tpbmRleF1dID0gdmFsO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIG9ialxyXG4gICAgICAgIH0sIHt9KTtcclxuXHJcbiAgICAgICAgLy8gc3RvcHMgdGhlIGxvb3BcclxuICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIG5vIHJvdXRlcyBtYXRjaGVkXHJcbiAgICAgIGlmICghbWF0Y2hGb3VuZCkge1xyXG4gICAgICAgIHJldHVybiBudWxsXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdmFsdWU6IHJvdXRlLnZhbHVlLFxyXG4gICAgICAgIHBhcmFtczogcGFyYW1zLFxyXG4gICAgICAgIHVybDogdXJsLFxyXG4gICAgICAgIHBhdHRlcm46IHJvdXRlLnBhdHRlcm5cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGluZGV4O1xyXG5cclxufSkpKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmVhdGhlci1yb3V0ZS1tYXRjaGVyLmpzLm1hcFxyXG4iXSwic291cmNlUm9vdCI6IiJ9